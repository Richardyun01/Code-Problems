/*
  알고리즘 분류: 다이나믹 프로그래밍, 가장 긴 증가하는 부분 수열 문제

  접근 방법 및 구현
  - [1, 2, 1, 3, 4, 2]
    - 1 -> [1], 2 -> [1] + '2' = [1, 2]
    - 1 -> [1]: 현재 값인 1보다 작은 값이 없음
    - 3 -> [1] 또는 [2] 또는 [1, 2] + '3' = [1, 2, 3] => 보유한 부분 수열 중 가장 긴 수열에 +1을 한 값이 가장 긴 부분 수열의 길이가 됨
    - 4 -> [1], [2], [1, 2], [1, 2, 3] + '4' = [1, 2, 3, 4] => 위의 법칙을 적용
    - 2 -> [1] + '2' = [1, 2] => 2보다 작은 부분 수열 중 가장 긴 수열에 더함
  - 일반화: 1~x-1 번째 값들 중 x번째 값보다 더 작은 숫자들이 갖는 부분 수열의 길이에서 가장 길이가 긴 부분 수열의 길이+1이 x번째 값이 가지는 가장 긴 증가하는 부분 수열의 길이
  - dp로 표현: dp[a] = b => a번째 값이 가지는 가장 긴 증가하는 부분 수열의 길이 = b
*/

#include<iostream>
#define endl '\n'
using namespace std;
int N, ans = 0;
int A[1001];
int dp[1001];
int Max(int a, int b) {
    if (a > b) return a;
    return b;
}
int main() {
    cin >> N;
    for (int i = 1; i <= N; i++) {
        cin >> A[i];
    }
    for (int i = 1; i <= N; i++) {
        // 수열의 시작 길이
        dp[i] = 1;
        for (int j = i-1; j >= 1; j--) {
            // 현재 기준 최댓값이 갱신될 경우
            if (A[i] > A[j]) {
                // 해당 값에서의 부분 수열의 최대 길이는 이전 최대 길이+1 또는 현재 길이
                dp[i] = Max(dp[i], dp[j] + 1);
// cout << "dp[" << i << "]: " << dp[i] << endl;
            }
        }
        // 수열 최대 길이 갱신
        ans = Max(dp[i], ans);
// cout << "current ans: " << ans << endl;
    }
    cout << ans << endl;
    return 0;
}